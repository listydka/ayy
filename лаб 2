import numpy as np
import random

# Функция для проверки, является ли число простым
def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

# Ввод данных
K = int(input("Введите K: "))
N = int(input("Введите N (четное число): "))

# Генерация матрицы A с случайными числами от -10 до 10
A = np.random.randint(-10, 11, (N, N))
print("Матрица A:")
print(A)

# Разбиение матрицы A на подматрицы B, C, D, E
half_N = N // 2
B = A[:half_N, :half_N]  # Верхняя левая подматрица
C = A[:half_N, half_N:]  # Верхняя правая подматрица
D = A[half_N:, :half_N]  # Нижняя левая подматрица
E = A[half_N:, half_N:]  # Нижняя правая подматрица

# Подсчет количества простых чисел в нечетных столбцах области 2 в C
prime_count = 0
for i in range(half_N):  # Перебираем строки подматрицы C
    for j in range(1, half_N, 2):  # Нечетные столбцы
        if is_prime(C[i, j]):
            prime_count += 1

# Подсчет количества нулей в четных строках области 3 в C
zero_count = 0
for i in range(1, half_N, 2):  # Четные строки
    for j in range(half_N):  # Перебираем все столбцы
        if C[i, j] == 0:
            zero_count += 1

# Формирование матрицы F в зависимости от условий
F = np.copy(A)
if prime_count > zero_count:
    # Корректная симметричная замена областей 1 и 3 в подматрице C
    top_part = np.copy(C[:half_N//2, :])  # Верхняя половина
    bottom_part = np.copy(C[half_N//2:, :])  # Нижняя половина
    
    # Меняем местами верхнюю и нижнюю части симметрично
    C[:half_N//2, :], C[half_N//2:, :] = bottom_part, top_part
else:
    # Несимметричная замена C и B
    F[:half_N, :half_N], F[:half_N, half_N:] = np.copy(F[:half_N, half_N:]), np.copy(F[:half_N, :half_N])

print("Матрица F:")
print(F)

# Вычисление выражения ((K * A) * F) – (K * A.T)
result = (K * A).dot(F) - (K * A.T)
print("Результат ((K * A) * F) – (K * A.T):")
print(result)
